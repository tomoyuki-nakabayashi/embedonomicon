<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>グローバルシングルトン - The Embedonomicon</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">序文</a></li><li class="chapter-item expanded "><a href="smallest-no-std.html"><strong aria-hidden="true">1.</strong> 最小限の#![no_std]プログラム</a></li><li class="chapter-item expanded "><a href="memory-layout.html"><strong aria-hidden="true">2.</strong> メモリレイアウト</a></li><li class="chapter-item expanded "><a href="main.html"><strong aria-hidden="true">3.</strong> mainインタフェース</a></li><li class="chapter-item expanded "><a href="exceptions.html"><strong aria-hidden="true">4.</strong> 例外処理</a></li><li class="chapter-item expanded "><a href="asm.html"><strong aria-hidden="true">5.</strong> stableでのアセンブリ</a></li><li class="chapter-item expanded "><a href="logging.html"><strong aria-hidden="true">6.</strong> シンボルでのロギング</a></li><li class="chapter-item expanded "><a href="singleton.html" class="active"><strong aria-hidden="true">7.</strong> グローバルシングルトン</a></li><li class="chapter-item expanded "><a href="dma.html"><strong aria-hidden="true">8.</strong> DMA</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="compiler-support.html">コンパイラサポートに関する覚書</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Embedonomicon</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- # Global singletons -->
<h1><a class="header" href="#グローバルシングルトン" id="グローバルシングルトン">グローバルシングルトン</a></h1>
<!-- 
In this section we'll cover how to implement a global, shared singleton. The
embedded Rust book covered local, owned singletons which are pretty much unique
to Rust. Global singletons are essentially the singleton pattern you see in C
and C++; they are not specific to embedded development but since they involve
symbols they seemed a good fit for the embedonomicon.
 -->
<p>このセクションでは、グローバルに共有されるシングルトンの実装方法を説明します。
The embedded Rust bookは、Rust特有のローカルで所有されるシングルトンを説明しました。
グローバルシングルトンは、本質的にCやC++で見かけるシングルトンパターンです。
これは、組込み開発固有のものではありませんが、シンボルに関係するため、embedonomiconに相応しい内容のように思えます。</p>
<!-- 内部的なTODOなので、そのまま残してあります。 -->
<blockquote>
<p><strong>TODO</strong>(resources team) link &quot;the embedded Rust book&quot; to the singletons
section when it's up</p>
</blockquote>
<!-- 
To illustrate this section we'll extend the logger we developed in the last
section to support global logging. The result will be very similar to the
`#[global_allocator]` feature covered in the embedded Rust book.
 -->
<p>グローバルシングルトンを説明するために、このセクションでは、前のセクションで開発したロガーを、
グローバルにログ出力できるように拡張します。
結果は、the embedded Rust bookで説明した<code>#[global_allocator]</code>フィーチャと非常に似たものになります。</p>
<!-- 内部的なTODOなので、そのまま残してあります。 -->
<blockquote>
<p><strong>TODO</strong>(resources team) link <code>#[global_allocator]</code> to the collections chapter
of the book when it's in a more stable location.</p>
</blockquote>
<!-- Here's the summary of what we want to: -->
<p>やりたいことを、下記にまとめます。</p>
<!-- 
In the last section we created a `log!` macro to log messages through a specific
logger, a value that implements the `Log` trait. The syntax of the `log!` macro
is `log!(logger, "String")`. We want to extend the macro such that
`log!("String")` also works. Using the `logger`-less version should log the
message through a global logger; this is how `std::println!` works. We'll also
need a mechanism to declare what the global logger is; this is the part that's
similar to `#[global_allocator]`.
 -->
<p>前のセクションでは、<code>Log</code>トレイトを実装している特定のロガーを通してログメッセージを出力するために、<code>log!</code>マクロを作りました。
<code>log!</code>マクロのシンタックスは、<code>log!(logger, &quot;String&quot;)</code>です。
このマクロを、<code>log!(&quot;String&quot;)</code>でも動くように拡張します。
<code>logger</code>なしのバージョンを使うと、グローバルロガーを通してメッセージをログ出力しなければなりません。
これは、<code>std::println!</code>が動作する方法と同じです。
また、何がグローバルロガーか、を宣言するための機構が必要です。
これは、<code>#[global_allocator]</code>と似ている部分です。</p>
<!-- 
It could be that the global logger is declared in the top crate and it could
also be that the type of the global logger is defined in the top crate. In this
scenario the dependencies can *not* know the exact type of the global logger. To
support this scenario we'll need some indirection.
 -->
<p>グローバルロガーが最上位クレートで宣言される可能性があり、
グローバルロガーの型もまた最上位クレートで定義される可能性があります。
この場合、依存関係から正確なグローバルロガーの型を知ることは<em>できません</em>。
この場合をサポートするために、いくらか間接的な方法が必要になります。</p>
<!-- 
Instead of hardcoding the type of the global logger in the `log` crate we'll
declare only the *interface* of the global logger in that crate. That is we'll
add a new trait, `GlobalLog`, to the `log` crate. The `log!` macro will also
have to make use of that trait.
 -->
<p><code>log</code>クレートにグローバルロガーの型をハードコーディングする代わりに、logクレート内で、
グローバルロガーの<em>インタフェース</em>だけを宣言します。
そのインタフェースは、<code>log</code>クレートに新しく追加する<code>GlobalLog</code>というトレイトです。
<code>log!</code>マクロもそのトレイトを使うようにします。</p>
<pre><code class="language-console">$ cat ../log/src/lib.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![no_std]

<span class="boring">fn main() {
</span>// 追加!
pub trait GlobalLog: Sync {
    fn log(&amp;self, address: u8);
}

pub trait Log {
    type Error;

    fn log(&amp;mut self, address: u8) -&gt; Result&lt;(), Self::Error&gt;;
}

#[macro_export]
macro_rules! log {
    // 追加!
    ($string:expr) =&gt; {
        unsafe {
            extern &quot;Rust&quot; {
                static LOGGER: &amp;'static dyn $crate::GlobalLog;
            }

            #[export_name = $string]
            #[link_section = &quot;.log&quot;]
            static SYMBOL: u8 = 0;

            $crate::GlobalLog::log(LOGGER, &amp;SYMBOL as *const u8 as usize as u8)
        }
    };

    ($logger:expr, $string:expr) =&gt; {{
        #[export_name = $string]
        #[link_section = &quot;.log&quot;]
        static SYMBOL: u8 = 0;

        $crate::Log::log(&amp;mut $logger, &amp;SYMBOL as *const u8 as usize as u8)
    }};
}

// 追加!
#[macro_export]
macro_rules! global_logger {
    ($logger:expr) =&gt; {
        #[no_mangle]
        pub static LOGGER: &amp;dyn $crate::GlobalLog = &amp;$logger;
    };
}
<span class="boring">}
</span></code></pre></pre>
<!-- There's quite a bit to unpack here. -->
<p>解説することがたくさんあります。</p>
<!-- Let's start with the trait. -->
<p>トレイトから始めましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait GlobalLog: Sync {
    fn log(&amp;self, address: u8);
}
<span class="boring">}
</span></code></pre></pre>
<!-- 
Both `GlobalLog` and `Log` have a `log` method. The difference is that
`GlobalLog.log` takes a shared reference to the receiver (`&self`). This is
necessary because the global logger will be a `static` variable. More on that
later.
 -->
<p><code>GlobalLog</code>と<code>Log</code>とは、<code>log</code>メソッドを持っています。違いは、<code>GlobalLog.log</code>がレシーバの共有参照(<code>&amp;self</code>)を取ることです。
グローバルロガーは<code>static</code>変数なので、これが必要です。後ほど、詳しく見ます。</p>
<!-- 
The other difference is that `GlobalLog.log` doesn't return a `Result`. This
means that it can *not* report errors to the caller. This is not a strict
requirement for traits used to implement global singletons. Error handling in
global singletons is fine but then all users of the global version of the `log!`
macro have to agree on the error type. Here we are simplifying the interface a
bit by having the `GlobalLog` implementer deal with the errors.
 -->
<p>もう1つの違う点は、<code>GlobalLog.log</code>は<code>Result</code>を返さないことです。
これは、呼び出し側にエラーを報告<em>できない</em>ことを意味します。
これはグローバルシングルトンを実装するトレイトを使うための必要条件ではありません。
グローバルシングルトンでエラー処理をすることは良いことですが、グローバルバージョンの<code>log!</code>マクロの全てのユーザーが、
エラー型に同意する必要があります。
ここでは、<code>GlobalLog</code>実装者がエラーを処理するようにして、インタフェースを少し簡略化します。</p>
<!-- 
Yet another difference is that `GlobalLog` requires that the implementer is
`Sync`, that is that it can be shared between threads. This is a requirement for
values placed in `static` variables; their types must implement the `Sync`
trait.
 -->
<p>さらに別の違いは、<code>GlobalLog</code>が実装者に、スレッド間で共有できるようにするための<code>Sync</code>を要求する点です。
これは、<code>static</code>変数内の値への要求です。それらの値の型は、<code>Sync</code>を実装しなければなりません。</p>
<!-- 
At this point it may not be entirely clear why the interface has to look this
way. The other parts of the crate will make this clearer so keep reading.
 -->
<p>現時点では、インタフェースがこのようになっていなければならない理由は、完全には明らかではないかもしれません。
クレートの他の部分を見ることで、より明らかになっていきますので、読み進めて下さい。</p>
<!-- Next up is the `log!` macro: -->
<p>次は<code>log!</code>マクロです。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    ($string:expr) =&gt; {
        unsafe {
            extern &quot;Rust&quot; {
                static LOGGER: &amp;'static dyn $crate::GlobalLog;
            }

            #[export_name = $string]
            #[link_section = &quot;.log&quot;]
            static SYMBOL: u8 = 0;

            $crate::GlobalLog::log(LOGGER, &amp;SYMBOL as *const u8 as usize as u8)
        }
    };
<span class="boring">}
</span></code></pre></pre>
<!-- 
When called without a specific `$logger` the macros uses an `extern` `static`
variable called `LOGGER` to log the message. This variable *is* the global
logger that's defined somewhere else; that's why we use the `extern` block. We
saw this pattern in the [main interface] chapter.
 -->
<p>特定の<code>$logger</code>なしでマクロを呼び出すと、マクロはメッセージをログ出力するために<code>LOGGER</code>と呼ばれる<code>extern</code> <code>static</code>変数を使います。
この変数<em>は</em>どこかで定義されたグローバルロガーです。そのため、<code>extern</code>ブロックを使っています。
このパターンは<a href="/main.html">メインインタフェース</a>の章で見ました。</p>
<!-- [main interface]: /main.html -->
<!-- 
We need to declare a type for `LOGGER` or the code won't type check. We don't
know the concrete type of `LOGGER` at this point but we know, or rather require,
that it implements the `GlobalLog` trait so we can use a trait object here.
 -->
<p><code>LOGGER</code>の型を宣言する必要があります。そうでなければ、コードは型チェックを行いません。
<code>LOGGER</code>の具体的な型はここではわかりませんが、
その型が<code>GlobalLog</code>トレイトを実装していることを知っています（むしろ必要としています）。
そこで、トレイトオブジェクトを使うことができます。</p>
<!-- 
The rest of the macro expansion looks very similar to the expansion of the local
version of the `log!` macro so I won't explain it here as it's explained in the
[previous] chapter.
 -->
<p>残りのマクロ拡張は、<code>log!</code>マクロのローカルバージョンの拡張ととてもよく似ています。
そのため、<a href="/logging.html">前の</a>章で説明したことは、ここでは説明しません。</p>
<!-- [previous]: /logging.html -->
<!-- 
Now that we know that `LOGGER` has to be a trait object it's clearer why we
omitted the associated `Error` type in `GlobalLog`. If we had not omitted then
we would have need to pick a type for `Error` in the type signature of `LOGGER`.
This is what I earlier meant by "all users of `log!` would need to agree on the
error type".
 -->
<p>ここで、<code>LOGGER</code>がトレイトオブジェクトでなければならないことを知っているので、
<code>GlobalLog</code>で関連型の<code>Error</code>を除去する理由はより明白です。もし除去しなければ、
<code>LOGGER</code>の型シグネチャの中で<code>Error</code>の型を1つ選ばなければなりません。
これが先程、「<code>log!</code>マクロの全てのユーザーが、エラー型に同意する必要があります。」と書いた意味です。</p>
<!-- 
Now the final piece: the `global_logger!` macro. It could have been a proc macro
attribute but it's easier to write a `macro_rules!` macro.
 -->
<p>そして、最後のピースの<code>global_logger!</code>マクロです。
これは、手続きマクロアトリビュートにもできますが、<code>macro_rules!</code>でマクロを書くほうが簡単です。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! global_logger {
    ($logger:expr) =&gt; {
        #[no_mangle]
        pub static LOGGER: &amp;dyn $crate::GlobalLog = &amp;$logger;
    };
}
<span class="boring">}
</span></code></pre></pre>
<!-- 
This macro creates the `LOGGER` variable that `log!` uses. Because we need a
stable ABI interface we use the `no_mangle` attribute. This way the symbol name
of `LOGGER` will be "LOGGER" which is what the `log!` macro expects.
 -->
<p>このマクロは、<code>log!</code>が使用する<code>LOGGER</code>変数を作ります。安定したABIインタフェースが必要なので、
<code>no_mangle</code>アトリビュートを使用します。
この方法により、<code>LOGGER</code>のシンボル名は<code>log!</code>マクロが期待する「LOGGER」になります。</p>
<!-- 
The other important bit is that the type of this static variable must exactly
match the type used in the expansion of the `log!` macro. If they don't match
Bad Stuff will happen due to ABI mismatch.
 -->
<p>他の重要な点は、このstatic変数の型は、<code>log!</code>マクロの展開で使用される型と正確に一致しなければなりません。
もし一致しない場合、ABIの不一致により、良くないことが起こるでしょう。</p>
<!-- 
Let's write an example that uses this new global logger functionality.
 -->
<p>新しいグローバルロガーの機能を使う例を書いてみましょう。</p>
<pre><code class="language-console">$ cat src/main.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use cortex_m::interrupt;
use cortex_m_semihosting::{
    debug,
    hio::{self, HStdout},
};

use log::{global_logger, log, GlobalLog};
use rt::entry;

struct Logger;

global_logger!(Logger);

entry!(main);

fn main() -&gt; ! {
    log!(&quot;Hello, world!&quot;);

    log!(&quot;Goodbye&quot;);

    debug::exit(debug::EXIT_SUCCESS);

    loop {}
}

impl GlobalLog for Logger {
    fn log(&amp;self, address: u8) {
        // `static mut`変数へのアクセスを割り込み安全にするため（これはメモリ安全のために要求されます）、
        // クリティカルセクション（`interrupt::free`）を使います。
        interrupt::free(|_| unsafe {
            static mut HSTDOUT: Option&lt;HStdout&gt; = None;

            // 遅延初期化
            if HSTDOUT.is_none() {
                HSTDOUT = Some(hio::hstdout()?);
            }

            let hstdout = HSTDOUT.as_mut().unwrap();

            hstdout.write_all(&amp;[address])
        }).ok(); // `.ok()` = エラーを無視します
    }
}
</code></pre></pre>
<!-- 内部的なTODOなので、そのまま残してあります。 -->
<blockquote>
<p><strong>TODO</strong>(resources team) use <code>cortex_m::Mutex</code> instead of a <code>static mut</code>
variable when <code>const fn</code> is stabilized.</p>
</blockquote>
<!-- We had to add `cortex-m` to the dependencies. -->
<p>依存関係に<code>cortex-m</code>を追加する必要があります。</p>
<pre><code class="language-console">$ tail -n5 Cargo.toml
</code></pre>
<pre><code class="language-text">[dependencies]
cortex-m = &quot;0.5.7&quot;
cortex-m-semihosting = &quot;0.3.1&quot;
log = { path = &quot;../log&quot; }
rt = { path = &quot;../rt&quot; }
</code></pre>
<!-- 
This is a port of one of the examples written in the [previous] section. The
output is the same as what we got back there.
 -->
<p>これは、<a href="/logging.html">前の</a>セクションで書いた例を移植したものです。
出力は、以前のものと同じです。</p>
<pre><code class="language-console">$ cargo run | xxd -p
</code></pre>
<pre><code class="language-text">0001
</code></pre>
<pre><code class="language-console">$ cargo objdump --bin app -- -t | grep '\.log'
</code></pre>
<pre><code class="language-text">00000001 g     O .log		 00000001 Goodbye
00000000 g     O .log		 00000001 Hello, world!
</code></pre>
<hr />
<!-- 
Some readers may be concerned about this implementation of global singletons not
being zero cost because it uses trait objects which involve dynamic dispatch,
that is method calls are performed through a vtable lookup.
 -->
<p>このグローバルシングルトンの実装がゼロコストでないことが気になる読者も居るかと思います。
なぜなら、トレイトオブジェクトを使用しており、vtableを参照してメソッド呼び出しを行う動的ディスパッチになるためです。</p>
<!-- 
However, it appears that LLVM is smart enough to eliminate the dynamic dispatch
when compiling with optimizations / LTO. This can be confirmed by searching for
`LOGGER` in the symbol table.
 -->
<p>しかし、LLVMは十分に賢く、この動的ディスパッチをコンパイラの最適化 / LTOで消去してくれます。
このことは、シンボルテーブル内の<code>LOGGER</code>を探すことで確認できます。</p>
<pre><code class="language-console">$ cargo objdump --bin app --release -- -t | grep LOGGER
</code></pre>
<pre><code class="language-text">
</code></pre>
<!-- 
If the `static` is missing that means that there is no vtable and that LLVM was
capable of transforming all the `LOGGER.log` calls into `Logger.log` calls.
 -->
<p>もし<code>static</code>が見つからない場合、vtableがないことと、
LLVMが<code>LOGGER.log</code>の呼び出しを<code>Logger.log</code>の呼び出しに変換できたことを意味します。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="logging.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="dma.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="logging.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="dma.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
